'''
날짜: 2025.04.15 20:00~21:20
링크: https://www.acmicpc.net/problem/2156
시간복잡도: O(N)

1.학습키워드
백트래킹인거같은데? -> 중복불가능하면 O(N!) N이 1만이라 불가능
이진탐색 아님.
dp? 

2.문제
포도주 일렬로 세워짐. 포도주를 최대로 먹어야함.
포도주1이면, 포도주1
포도주2이면, 포도주2
포도주3이면, ? 3까지의 최댓값
포도주4이면, ? 4까지의 최댓값
...
포도주n이면, ? n까지의 최댓값

마지막 잔 먹었을때, 마지막잔 안먹었을때 보자.
현재위치가 오른쪽에 위치한 n이라면
x o -> n-2번쨰까지의 최댓값 + n값 = dp[n-2] + arr[n]
o o -> n-3까지의 최댓값 + n-1값 + n값 = dp[n-3] + arr[n-1] + arr[n]
  x -> n-1까지의 최댓값 = dp[n-1]

3.어떤 문제가 있었고, 나는 어떤 시도를 했는지
가능한 경우의 수를 점화식으로 생각해내는게 어려웠다.

4.어떻게 해결했는지
dp구현
  
5.무엇을 새롭게 알았는지
백트래킹의 시간복잡도를 알았다. 중복이 안되면 O(N!), 중복이되면 O(N^N)
N범위보고 백트래킹은 걸러야했음.

'''

'''
1.입력받기
2.dp구현
'''

import sys

# 1.입력받기
n = int(sys.stdin.readline())
arr = [0]*10001
for i in range(1, n+1):
    arr[i] = int(sys.stdin.readline())
    
# 2.dp구현
dp = [0] * 10001
dp[1] = arr[1]
dp[2] = arr[1] + arr[2]
for i in range(3, n+1):
    dp[i] = max(dp[i-2]+arr[i], dp[i-3]+arr[i-1]+arr[i], dp[i-1])

print(max(dp))


    